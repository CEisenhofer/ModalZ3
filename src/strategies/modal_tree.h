#pragma once

#include <utility>

#include "hashed_list.h"
#include "syntax_tree.h"

class modal_tree_node;

struct spread_info {
    syntax_tree_node* m_template;
    z3::expr_vector m_justifications;

    spread_info(syntax_tree_node* temp, const z3::expr_vector& justifications) : m_template(temp), m_justifications(justifications) {}
};

struct connection_info {
    modal_tree_node* m_from;
    modal_tree_node* m_to;
    z3::expr_vector m_justifications; // can be multiple (e.g., for transitivity two worlds)

    connection_info(modal_tree_node* from, modal_tree_node* to, const z3::expr_vector& justifications) : m_from(from), m_to(to), m_justifications(justifications) {}

    bool operator==(const connection_info& other) const {
        return m_from == other.m_from && m_to == other.m_to;
    }
};

class modal_tree_node;

struct get_from {
    modal_tree_node* operator()(const connection_info& c) const;
};

struct get_to {
    modal_tree_node* operator()(const connection_info& c) const;
};

class modal_tree_node {
    
    friend class modal_tree;

    unsigned m_idx; // index of this world in the existing world-list

    const bool m_named; // given by the user or generated by the solver
    
    syntax_tree_node* m_abstract;
    connection_info m_skolem_info;
    std::vector<hashed_list<connection_info, get_to, modal_tree_node*>> m_existing_children; // negative modal operators
    std::vector<hashed_list<connection_info, get_from, modal_tree_node*>> m_existing_parents; // inverse mapping from m_existing_children
    std::vector<std::vector<spread_info>> m_spread; // positive modal operators

    // contains also children that have been removed again by backtracking
    // => CDCL might assign even values, although they do not even exist any more (we have to retain them)
    // does not contain children that were linked explicitly (e.g., reachable(w1, w2)) 
    // -> none of m_existing_children and m_created_children are subsets of each other 
    std::vector<modal_tree_node*> m_created_children; // indexed by abstract id

    z3::expr m_world_constant; // also don't use this as the name; it might look ugly
    std::vector<Z3_lbool> m_assignment_set;
    std::vector<unsigned> m_assignment_list;
    
    modal_tree_node* m_blocked_by = nullptr;

public:
    
    modal_tree_node(unsigned id, bool named, syntax_tree_node* abs, modal_tree_node* parent, const z3::expr& world_constant, const z3::expr_vector& just) : m_idx(id), m_named(named), m_abstract(abs), m_skolem_info(parent, this, just), m_world_constant(world_constant) {}
    
    virtual ~modal_tree_node() { }

    unsigned get_internal_idx() const { // Be cautious. This index may change over time!!
        return m_idx;
    }

    bool is_named() const {
        return m_named;
    }

    syntax_tree_node* get_syntax_node() const {
        return m_abstract;
    }
    
    modal_tree_node* blocked_by() const {
        return m_blocked_by;
    }
    
    z3::expr world_constant() const {
        return m_world_constant;
    }
    
    z3::expr_vector justification() const { // the reason that this world was generated (maybe just empty - e.g., ABox or implicit first world)
        return get_parent_connection().m_justifications;
    }

    bool is_assigned(unsigned variable) const;

    Z3_lbool get_assignment(unsigned variable) const;

    unsigned get_assignment_cnt() const {
        return m_assignment_set.size();
    }

    void unassign(unsigned variable);

    void assign(unsigned variable, bool val);

    void assign(unsigned variable, Z3_lbool val);

    bool is_root() const {
        return m_skolem_info.m_from == nullptr;
    }
    
    const connection_info& get_parent_connection() const {
        return m_skolem_info;
    }

    void add_spread(const spread_info& info, unsigned relation);

    unsigned get_spread_relation_cnt() const {
        return m_spread.size();
    }

    const std::vector<spread_info>& get_spread(unsigned relation) const {
        SASSERT(relation < m_spread.size());
        return m_spread[relation];
    }

    void add_skolem_child(modal_tree_node* node, syntax_tree_node* abs);
    bool add_named_child(const connection_info& existing, unsigned relation);

    unsigned get_child_relations_cnt() const {
        return m_existing_children.size();
    }

    unsigned get_parent_relations_cnt() const {
        return m_existing_parents.size();
    }

    modal_tree_node* get_created_child(syntax_tree_node* abs);

    const std::vector<connection_info>& get_parents(unsigned relation) const {
        SASSERT(relation < m_existing_parents.size());
        return m_existing_parents[relation].get_vector();
    }

    const std::vector<connection_info>& get_children(unsigned relation) const {
        SASSERT(relation < m_existing_children.size());
        return m_existing_children[relation].get_vector();
    }

    void remove_child(modal_tree_node* child, unsigned relation);
    
    void remove_last_spread(unsigned relation);
    
    bool is_blocked(); // subset blocking
};

std::ostream& operator<<(std::ostream& os, const modal_tree_node& w);

class modal_tree {
    
    z3::context& m_ctx;

    syntax_tree* m_syntax;

    std::vector<modal_tree_node*> m_existing_nodes;
    std::vector<modal_tree_node*> m_actual_nodes; // superset of existing worlds (those in the model)
    std::unordered_map<z3::expr, modal_tree_node*, expr_hash, expr_eq> m_expr_to_node;
    
public:
    
    modal_tree(syntax_tree* syn) : m_ctx(syn->ctx()), m_syntax(syn) {
        get_or_create_node(syn->get_root(), nullptr, z3::expr_vector(m_ctx));
    }
    
    modal_tree_node* get_root() const {
        SASSERT(!m_existing_nodes.empty());
        SASSERT(m_existing_nodes[0]->is_root());
        return m_existing_nodes[0];
    }

    z3::sort get_world_sort() const {
        return m_syntax->get_world_sort();
    }
    
    modal_tree_node* get_or_create_node(syntax_tree_node* abs, modal_tree_node* parent, const z3::expr_vector& justification) {
        return get_or_create_node(abs, parent, justification, z3::expr(m_ctx));
    }
    modal_tree_node* get_or_create_node(syntax_tree_node* abs, modal_tree_node* parent, const z3::expr_vector& justification, z3::expr world_constant);
    modal_tree_node* get_or_create_named_node(const z3::expr& w) {
        modal_tree_node* node = get(w);
        if (node)
            return node;
        return get_or_create_node(nullptr, nullptr, z3::expr_vector(m_ctx), w); // might consist of more abstract syntax nodes. Either we add all or none
    }

    ~modal_tree() {
        for (unsigned i = 0; i < m_actual_nodes.size(); i++)
            delete m_actual_nodes[i];
    }
    
    unsigned existing_size() const {
        return m_existing_nodes.size();
    }

    modal_tree_node* get(const z3::expr& e) const {
        auto iterator = m_expr_to_node.find(e);
        if (iterator == m_expr_to_node.end())
            return nullptr;
        return iterator->second;
    }

    const std::vector<modal_tree_node*>& get_existing_worlds() const {
        return m_existing_nodes;
    };

    void remove_world(modal_tree_node* world);
    
    // should not be used for reasoning after these calls
    void remove_blocked();
    void transitive_closure(unsigned relation);

};

std::ostream& operator<<(std::ostream& os, const modal_tree& m);
