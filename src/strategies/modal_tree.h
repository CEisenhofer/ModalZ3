#pragma once

#include <utility>

#include "syntax_tree.h"

class modal_tree_node;

struct spread_info {
    syntax_tree_node* m_template;
    z3::expr m_justification;

    spread_info(syntax_tree_node* temp, z3::expr justification) : m_template(temp), m_justification(std::move(justification)) {}
};

struct connection_info {
    modal_tree_node* m_from;
    modal_tree_node* m_to;
    z3::expr m_justification;

    connection_info(modal_tree_node* from, modal_tree_node* to, z3::expr justification) : m_from(from), m_to(to), m_justification(std::move(justification)) {}

    bool operator==(const connection_info& other) const {
        return m_from == other.m_from && m_to == other.m_to && z3::eq(m_justification, other.m_justification);
    }
};

class modal_tree_node {
    
    friend class modal_tree;

    const unsigned m_id; // resist the temptation to use this as the name; the user may has already defined a world with this name
    const bool m_named; // given by the user or generated by the solver
    
    syntax_tree_node* m_abstract;
    connection_info m_skolem_info;
    std::vector<std::vector<connection_info>> m_existing_children; // negative modal operators
    std::vector<std::vector<spread_info>> m_spread; // positive modal operators

    // contains also children that have been removed again by backtracking
    // => CDCL might assign even values, although they do not even exist any more (we have to retain them)
    // does not contain children that were linked explicitly (e.g., reachable(w1, w2)) 
    // -> none of m_existing_children and m_created_children are subsets of each other 
    std::vector<modal_tree_node*> m_created_children; // indexed by abstract id

    z3::expr m_world_constant; // also don't use this as the name; it might look ugly
    std::vector<Z3_lbool> m_assignment_set;
    std::vector<unsigned> m_assignment_list;
    
    modal_tree_node* m_blocked_by = nullptr;

public:
    
    modal_tree_node(unsigned id, bool named, syntax_tree_node* abs, modal_tree_node* parent, const z3::expr& world_constant, const z3::expr& aux_predicate) : m_id(id), m_named(named), m_abstract(abs), m_skolem_info(parent, this, aux_predicate), m_world_constant(world_constant) {}
    
    virtual ~modal_tree_node() { }

    unsigned get_id() const { // don't use for outputting; just an internal identifier!!
        return m_id;
    }

    bool is_named() const {
        return m_named;
    }

    syntax_tree_node* get_syntax_node() const {
        return m_abstract;
    }
    
    modal_tree_node* blocked_by() const {
        return m_blocked_by;
    }
    
    z3::expr world_constant() const {
        return m_world_constant;
    }
    
    z3::expr aux_predicate() const { // the reason that this world was generated (may be just true - e.g., ABox or implicit first world)
        const connection_info& parent = get_parent_connection();
        SASSERT(parent.m_justification.is_true() || (parent.m_justification.num_args() == 1 && eq(parent.m_justification.arg(0), parent.m_from->world_constant())));
        return parent.m_justification;
    }

    bool is_assigned(unsigned variable) const;

    Z3_lbool get_assignment(unsigned variable) const;

    unsigned get_assignment_cnt() const {
        return m_assignment_set.size();
    }

    void unassign(unsigned variable);

    void assign(unsigned variable, bool val);

    void assign(unsigned variable, Z3_lbool val);

    bool is_root() const {
        return m_skolem_info.m_from == nullptr;
    }
    
    const connection_info& get_parent_connection() const {
        return m_skolem_info;
    }

    void add_spread(const spread_info& info, unsigned relation);

    const spread_info& last_spread(unsigned relation) const;

    unsigned get_spread_relation_cnt() const {
        return m_spread.size();
    }

    const std::vector<spread_info>& get_spread(unsigned relation) const {
        SASSERT(relation < m_spread.size());
        return m_spread[relation];
    }

    void add_skolem_child(modal_tree_node* node, syntax_tree_node* abs);
    void add_named_child(const connection_info& existing, unsigned relation);

    const modal_tree_node* last_child(unsigned relation) const;

    unsigned get_child_relations_cnt() const {
        return m_existing_children.size();
    }

    modal_tree_node* get_created_child(syntax_tree_node* abs);

    const std::vector<connection_info>& get_children(unsigned relation) const {
        SASSERT(relation < m_existing_children.size());
        return m_existing_children[relation];
    }

    void remove_and_delete_last_child(unsigned relation);
    void remove_child(modal_tree_node* child, unsigned relation); // DON'T call during reasoning - after this call instable because of shuffling
    
    void remove_last_spread(unsigned relation);
    
    bool is_blocked();
};

std::ostream& operator<<(std::ostream& os, const modal_tree_node& w);

class modal_tree {
    
    z3::context& m_ctx;

    syntax_tree* m_syntax;

    std::vector<modal_tree_node*> m_existing_nodes;
    std::vector<modal_tree_node*> m_actual_nodes; // superset of existing worlds (those in the model)
    std::unordered_map<z3::expr, modal_tree_node*, expr_hash, expr_eq> m_expr_to_node;
    
public:
    
    modal_tree(syntax_tree* syn) : m_ctx(syn->ctx()), m_syntax(syn) {
        get_or_create_node(syn->get_root(), nullptr, m_ctx.bool_val(true));
    }
    
    modal_tree_node* get_root() const {
        SASSERT(!m_existing_nodes.empty());
        SASSERT(m_existing_nodes[0]->is_root());
        return m_existing_nodes[0];
    }

    z3::sort get_world_sort() const {
        return m_syntax->get_world_sort();
    }
    
    modal_tree_node* get_or_create_node(syntax_tree_node* abs, modal_tree_node* parent, const z3::expr& aux_predicate) {
        return get_or_create_node(abs, parent, aux_predicate, z3::expr(m_ctx));
    }
    modal_tree_node* get_or_create_node(syntax_tree_node* abs, modal_tree_node* parent, const z3::expr& aux_predicate, z3::expr world_constant);
    modal_tree_node* get_or_create_named_node(const z3::expr& w) {
        modal_tree_node* node = get(w);
        if (node)
            return node;
        return get_or_create_node(nullptr, nullptr, m_ctx.bool_val(true), w); // might consist of more abstract syntax nodes. Either we add all or none
    }

    ~modal_tree() {
        for (unsigned i = 0; i < m_actual_nodes.size(); i++)
            delete m_actual_nodes[i];
    }
    
    unsigned existing_size() const {
        return m_existing_nodes.size();
    }

    unsigned actual_size() const {
        return m_actual_nodes.size();
    }

    modal_tree_node* get(const z3::expr& e) const {
        auto iterator = m_expr_to_node.find(e);
        if (iterator == m_expr_to_node.end())
            return nullptr;
        return iterator->second;
    }

    const std::vector<modal_tree_node*>& get_existing_worlds() const {
        return m_existing_nodes;
    };

    void undo_last_child(unsigned relation);
    
    // should not be used for reasoning after this call 
    void remove_blocked();
    
};

std::ostream& operator<<(std::ostream& os, const modal_tree& m);
